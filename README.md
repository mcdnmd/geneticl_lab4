# ГЕНЕТИЧЕСКИЙ АЛГОРИТМ ДЛЯ РЕШЕНИЯ ЗАДАЧИ КОММИВОЯЖЁРА
Целью данной работы является получение навыков разработки
эволюционных алгоритмов для решения комбинаторных задач на примере
задачи коммивояжёра.

## Результаты запусков
| Проблема | Размер | Popszie | Gens  | Длина маршрута | Кол-во итераций сходимости | Оптимальный маршрут |
|----------|--------|---------|-------|----------------|----------------------------|---------------------|
| xqf131   | 131    | 10      | 1000  | 2233.99        | 982.8                      | 1997.15             |
| xqf131   | 131    | 10      | 10000 | 987.91         | 9837.7                     | 904.94              |
| xqf131   | 131    | 10      | 20000 | 775.77         | 19659.55                   | 727.22              |
| xqf131   | 131    | 50      | 1000  | 2203.68        | 972.95                     | 1968.5              |
| xqf131   | 131    | 100     | 1000  | 2189.73        | 963.65                     | 1988.41             |
| xqg237   | 237    | 10      | 1000  | 7232.18        | 972.85                     | 6895.49             |
| xqg237   | 237    | 10      | 10000 | 3192.03        | 9863.3                     | 3001.23             |
| xqg237   | 237    | 10      | 20000 | 2403.63        | 19831.1                    | 2175.18             |
| bcl380   | 380    | 10      | 1000  | 17513.70       | 977.1                      | 17060.80            |
| bcl380   | 380    | 10      | 10000 | 8626.52        | 9941.45                    | 8226.35             |
| bcl380   | 380    | 10      | 20000 | 6570.53        | 19904                      | 6299.8              |


## Короссовер

1. **Метод `mate`**:
    - Этот метод переопределен из суперкласса `AbstractCrossover`.
    - Он принимает две особи (`parent1` и `parent2`) для скрещивания, индекс (не используется в данной реализации) и генератор случайных чисел.
    - Метод создает два потомка, вызывая метод `orderCrossover` дважды с разными родителями в качестве параметров.

2. **Метод `orderCrossover`**:
    - Этот метод выполняет операцию кроссовера "порядковый кроссовер" между двумя родителями.
    - Он принимает двух родителей (`parent1` и `parent2`) и генератор случайных чисел.
    - Затем он выбирает два случайных индекса, которые будут определять точки раздела генов от каждого родителя.
    - После этого метод вызывает вспомогательный метод `performOrderCrossover`, который выполняет сам процесс кроссовера.

3. **Метод `performOrderCrossover`**:
    - Этот метод реализует процесс кроссовера для операции "порядковый кроссовер".
    - Он принимает два списка генов родителей, а также индексы точек раздела.
    - Метод сначала копирует гены из родительского первого родителя между точками раздела в потомка.
    - Затем он проходит по генам второго родителя в порядке их появления и добавляет те из них в потомка, которых еще нет в потомке.
    - Таким образом, порядок генов от первого родителя сохраняется, а гены от второго родителя добавляются в порядке, в котором они встречаются.

## Мутация
1. **Метод `apply`**:
    - Этот метод принимает два аргумента: `population` - список решений (особей) в текущей популяции и `random` - генератор случайных чисел.
    - Для каждой особи в популяции он выполняет мутацию вызовом метода `scrambleMutation`.
    - После применения мутации к каждой особи, метод возвращает измененную популяцию.

2. **Метод `scrambleMutation`**:
    - Этот метод выполняет мутацию "перемешивание" для конкретного маршрута коммивояжера.
    - Он принимает два аргумента: `tour` - список, представляющий маршрут, и `random` - генератор случайных чисел.
    - Сначала метод генерирует два случайных индекса в пределах размера маршрута. Эти индексы указывают начальную и конечную позицию для перемешивания.
    - Затем он определяет начальную и конечную позиции для перемешивания в маршруте, выбирая минимальный и максимальный из двух сгенерированных случайных индексов.
    - После этого он перемешивает подсписок маршрута между этими позициями, используя метод `Collections.shuffle`. Это означает, что порядок городов в выбранной части маршрута будет случайным образом изменен.


Таким образом, метод `apply` вызывает `scrambleMutation` для каждой особи в популяции, а `scrambleMutation` выполняет конкретную операцию мутации "перемешивание" на маршруте коммивояжера.


## Ответы на вопросы
1. **Можно ли определить, что полученное решение является глобальным ‘оптимумом?**
    - Нет, в общем случае нельзя однозначно определить, что полученное решение является глобальным оптимумом. Задача коммивояжера относится к NP-трудным, и не существует эффективного алгоритма для поиска глобального оптимума за полиномиальное время.


2. **Можно ли допускать невалидные решения (с повторением городов)? Если да, то как обрабатывать такие решения и как это повлияет на производительность алгоритма?**
    - Обычно в задаче коммивояжера невалидные решения, содержащие повторения городов, не допускаются, так как требуется посетить каждый город ровно один раз.


3. **Как изменится задача, если убрать условие необходимости возврата в исходную точку маршрута?**
    - Если убрать условие необходимости возврата в исходную точку маршрута (то есть, задача станет открытой, а не закрытой), это приведет к изменениям в определении оптимального маршрута.